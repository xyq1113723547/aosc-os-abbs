<h1 id="proxy-server">Proxy Server</h1>
<p>The proxy server is used for starting or accessing multiple xpra sessions through a single entry point, without requiring SSH for transport or authentication.</p>
<p>This can be useful for hosts that have a limited number of publicly accessible ports or for clients accessing servers through firewalls with outbound port filtering. (ie: you can put the server on port 80 or 443 and access many sessions from this single port)</p>
<p>When started as <code>root</code>, which is the case when the proxy server runs as a <a href="./Service.html">system service</a>, this can also help to ensure that the sessions outlive the environment they were started from.</p>
<h2 id="configuration">Configuration</h2>
<p>Depending on the <a href="./Authentication.html">authentication</a> module configured, the proxy server can: * expose all the local sessions and start new ones (this is the default behaviour) * provide access to a custom list of sessions (ie: using the <code>sqlite</code> authentication module)</p>
<h2 id="gpu-accelerated-transcoding">GPU Accelerated Transcoding</h2>
<p>If the proxy server has access to a hardware accelerated encoding device (ie: <a href="./NVENC.html">NVENC</a>) and the servers it proxies do not, then it can automatically be used for speeding up screen update compression. (details in <a href="../issues/504">#504</a>)</p>
<h2 id="diagram">Diagram</h2>
<p>Here is an example architecture using the proxy server to provide access to a number of servers through a single port, also showing where NVENC hardware encoders and TCP proxying (apache, nginx, thttp,..) can all hook into:</p>
<figure>
<img src="https://xpra.org/images/Xpra-Proxy.png" alt="Xpra Proxy Diagram" /><figcaption aria-hidden="true">Xpra Proxy Diagram</figcaption>
</figure>
<details>
<summary>
Setup example
</summary>
<p><em>Beware</em>: to simplify these instructions, we use the <code>allow</code> authentication module, which does <em>no</em> checking whatsoever!</p>
<p>start a session on display <code>:100</code> with an <code>xterm</code>, this session is not exposed via TCP as there is no <code>bind-tcp</code> option:</p>
<pre class="shell"><code>xpra start :100 --start=xterm</code></pre>
<p>start a proxy server available on tcp port 14501:</p>
<pre class="shell"><code>xpra proxy :20 --tcp-auth=allow --bind-tcp=0.0.0.0:14501</code></pre>
<p>if only one session exists for this user, you can connect via the proxy with:</p>
<pre class="shell"><code>xpra attach tcp://foo:bar@PROXYHOST:14501/</code></pre>
<p>If there is more than one existing session accessible for this user account, the client also needs to specify which display it wishes to connect to using the extended attach syntax: <code>tcp/USERNAME:PASSWORD@SERVER:PORT/DISPLAY</code>:</p>
<pre class="shell"><code>xpra attach tcp://foo:bar@PROXYHOST:14501/100</code></pre>
Notes: * this example uses TCP, but the proxy works equally well with all other transports (<code>SSL</code>, etc) * the username “foo” and password “bar” can be replaced with anything since the <code>allow</code> authentication module does not check the credentials * if you run this command as root, all the user sessions will be exposed! * if you run it a normal user, only this user’s session will be exposed * when running the proxy server as root, once authenticated, the proxy server spawns a new process and no longer runs as root * the display number chosen for the proxy server is only used for identifying the proxy server and interacting with it using the regular tools (<code>xpra info</code>, etc) * to use ports lower than 1024 either use <code>--min-port</code> and run as root or see <a href="https://superuser.com/questions/710253/">allow non-root process to bind to port 80 and 443</a>
</details>
<h2 id="info-and-control">Info and Control</h2>
<p>When the client requests information from the server (ie: for the session info dialog or for internal use), the requests are passed through the proxy instance to the real server just like other packets, but the response is augmented with some extra information from the proxy server. (it is prefixed to prevent any interference)</p>
<p>Just like any other xpra server instance, a proxy instance can be also be queried directly. Since proxy instances do not have their own display number, each proxy instance will create a socket using the process ID instead (ie: <code>:proxy-15452</code>), you ca n find their names using <code>xpra list</code>.</p>
<h2 id="stopping">Stopping</h2>
<p>You can stop the proxy server just like any other servers with <code>xpra stop :$PROXYDISPLAY</code>.</p>
<p>If you want to stop an individual proxy connection instead, you must identify the proxy instance that you want to stop then use <code>xpra stop :proxy-$PROXYPID</code>.</p>
<p>You can identify proxy instances in a number of ways: * using system network tools that list processes and the hosts they are connected to (ie: <code>lsof</code>, <code>netstat</code>) * using <code>xpra info</code> on a specific proxy instance * from the proxy server log file * from the proxy instance log file etc..</p>
<details>
<summary>
Remote Hosts Example
</summary>
<p>This example uses a <code>sqlite</code> database to expose two remote server instances accessible from the proxy server via <code>TCP</code>.</p>
<p>Start the two sessions we wish to access via the <code>PROXYHOST</code> (we call this <code>TARGETHOST</code> - for testing, this can be the same host as <code>PROXYHOST</code>). On <code>TARGETHOST</code>:</p>
<pre class="shell"><code>xpra start :200 --bind-tcp=0.0.0.0:10100 --start=xterm
xpra start :201 --bind-tcp=0.0.0.0:10101 --start=xterm</code></pre>
<p>Start a proxy server on port 14501 using the “<code>sqlite</code>” authentication module (we will call this server <code>PROXYHOST</code>):</p>
<pre class="shell"><code>xpra proxy :100 --bind-tcp=0.0.0.0:14501,auth=sqlite:filename=./xpra-auth.sdb --socket-dir=/tmp</code></pre>
<p>and add user entries (ie: <code>foo</code> with password <code>bar</code>), pointing to the <code>TARGETHOST</code> sessions (ie: <code>192.168.1.200</code> is the <code>TARGETHOST</code>’s IP in this example):</p>
<pre class="shell"><code>SQLITE_AUTH_PY=/usr/lib64/python3.9/site-packages/xpra/server/auth/sqlite_auth.py
python $SQLITE_AUTH_PY ./xpra-auth.sdb create
python $SQLITE_AUTH_PY ./xpra-auth.sdb add foo bar nobody nobody tcp://192.168.1.200:10100/
python $SQLITE_AUTH_PY ./xpra-auth.sdb add moo cow nobody nobody tcp://192.168.1.200:10101/ &quot;&quot; &quot;compression=0&quot;</code></pre>
<p>connect the client through the proxy server to the first session:</p>
<pre class="shell"><code>xpra attach tcp://foo:bar@$PROXYHOST:14501/</code></pre>
<p>or for the second session:</p>
<pre class="shell"><code>xpra attach tcp://moo:cow@$PROXYHOST:14501/</code></pre>
<p>To hide the password from the command line history and process list, you can use a password file:</p>
<pre class="shell"><code>echo -n &quot;bar&quot; &gt; ./password.txt
xpra attach --password-file=./password.txt tcp://foo@$PROXYHOST:14501/</code></pre>
<p>What happens: * the client connects to the proxy server * the proxy server asks the client to authenticate and sends it a challenge * the client responds to the challenge * the proxy server verifies the challenge (and disconnects the user if needed) * the proxy server identifies the session desired (ie: the one on <code>TARGETHOST</code>) * the proxy server creates a new connection to the real server (<code>TARGETHOST</code>), applying any options specified (ie: “<code>compression=0</code>” will disable compression between the proxy and server) * the proxy server spawns a new process * the new proxy process changes its uid and gid to ‘nobody’ / ‘nobody’ (if the proxy server runs as root only, otherwise unchanged) * the packets should now flow through between the client and the real server</p>
Further notes: * for authentication between the proxy and the real server, just specify the username and password in the connection string * you can omit the uid and gid and the special user / group “nobody” will be used (Posix servers only) * this example uses <code>socket-dir=/tmp</code> to ensure that the proxy instances can create their sockets, no matter what user they runs as (nobody) - this is not always necessary (ie: not usually needed when running as non-root) * you can specify the uid and gid using their names (ie: uid=“joe”, gid=“users”, Posix servers only) or numerical values (ie: 1000) * you can specify more than one remote session string for each username and password pair using CSV format - but the client will then have to specify which one it wants on the connection URL
</details>
<h2 id="username-matters">Username Matters</h2>
<p>The proxy server can also be used to expose all local sessions dynamically.<br />
This is what the <a href="./Service.html">system service</a> (aka “system wide proxy server”) does.</p>
<p>In this case, the username, uid and gid are used to locate all the sessions for the user once it has authenticated, in the same way that a user can list sessions by running <code>xpra list</code>. This type of proxy server usually runs as root to be able to access the sessions for multiple users.</p>
<p>This mode of operation cannot be used with the <code>sqlite</code> or <code>multifile</code> authentication modules since those modules specify the list of sessions explicitly.</p>
<p>For some authentication modules the uid and gid can be derived from the username automatically using the password database (ie: <code>pam</code>, others allow for it to be specified as a module option (ie: <code>--tcp-auth=ldap,uid=xpraproxy,gid=xpraproxy</code>) which makes it possible for non-local accounts to execute the proxy process instance as a non-root user. The default value of <code>nobody</code> uid and <code>nobody</code> gid may or may not have sufficient privileges for executing a proxy process instance.</p>
<p>You should not use the <code>file</code>, <code>env</code> or <code>exec</code> authentication modules, as those would allow access to all usernames with the same password value.</p>
